<!DOCTYPE html><html lang="ko-KR" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="일 전"><meta name="hour-prompt" content="시간 전"><meta name="minute-prompt" content="분 전"><meta name="justnow-prompt" content="방금"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Ray Tracing (1) - 강의 리뷰" /><meta name="author" content="Veldic" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Review of Ray Tracing Lecture" /><meta property="og:description" content="Review of Ray Tracing Lecture" /><link rel="canonical" href="https://veldic.github.io/posts/ray-tracing-1/" /><meta property="og:url" content="https://veldic.github.io/posts/ray-tracing-1/" /><meta property="og:site_name" content="Veldic’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-07-10T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Ray Tracing (1) - 강의 리뷰" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Veldic"},"description":"Review of Ray Tracing Lecture","url":"https://veldic.github.io/posts/ray-tracing-1/","@type":"BlogPosting","headline":"Ray Tracing (1) - 강의 리뷰","dateModified":"2024-07-10T18:44:38+09:00","datePublished":"2024-07-10T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://veldic.github.io/posts/ray-tracing-1/"},"@context":"https://schema.org"}</script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } }, tex2jax: { inlineMath: [ ['$', '$'] ], displayMath: [ ['$$', '$$'] ], processEscapes: true, } }); MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) { alert("Math Processing Error: "+message[1]); }); MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) { alert("Math Processing Error: "+message[1]); }); </script> <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script><title>Ray Tracing (1) - 강의 리뷰 | Veldic's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Veldic's Blog"><meta name="application-name" content="Veldic's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="ko-KR"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile/profile_image.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Veldic's Blog</a></div><div class="site-subtitle font-italic">Trying to do better.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/veldic" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://instagram.com/square_min_v" aria-label="instagram" target="_blank" rel="noopener"> <i class="fab fa-instagram"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['rsual','snu.ac.kr'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Ray Tracing (1) - 강의 리뷰</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Ray Tracing (1) - 강의 리뷰</h1><div class="post-meta text-muted"><div> By <em> Veldic </em></div><div class="d-flex"><div> <span> 게시 <em class="timeago" date="2024-07-10 00:00:00 +0900" data-toggle="tooltip" data-placement="bottom" title="2024-07-10, 00:00 +0900" >07월 10일</em> </span> <span> 업데이트 <em class="timeago" date="2024-07-10 18:44:38 +0900 " data-toggle="tooltip" data-placement="bottom" title="2024-07-10, 18:44 +0900" >07월 10일</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3708 단어"> <em>20 분</em> </span></div></div></div><div class="post-content"><h2 id="들어가며">들어가며<a href="#들어가며" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>2024년 봄학기에 컴퓨터 그래픽스 강의를 수강하였다. 과거 2021년에 전공선택 강의였던 그래픽스 강의를 수강신청 했었다가 다른 전공필수 강의들의 로드를 감당할 수 없어서 수강취소를 선택했었다. 하지만 그 이후 담당하시던 교수님이 학교를 떠나시게 되면서 2022년, 2023년에는 강의가 열리지 않았다. 이에 졸업하기 전에 그래픽스 강의를 듣지 못하고 졸업하지 않을까 걱정했었는데 다행히도 2024년에 새로운 교수님께서 그래픽스 강의를 개설하셔서 다행히 듣고 졸업할 수 있게 되었다.</p><p>강의는 그래픽스의 기본적인 내용들을 전체적으로 훑는 식의 강의로 진행되었다. 3D Geometry, Viewing Pipeline, Subdivision, Rasterization, Texture, Color 등 컴퓨터 그래픽스를 구성하는 다양한 주제에 대해 배우게 되었다. 여기서 다룬 내용은 추후에 기회가 된다면 글로 작성해보도록 하겠다.</p><p>다양한 주제 중에서 가장 인상깊었던 내용은 Ray Tracing 이었다. 어쩌면 당연한 것이 컴퓨터 그래픽을 통해서 실제와 가까운 이미지를 뽑아낸다는 것이 일종의 그래픽스를 배우는 데 있어서 목표라고 생각했기 때문이다. 본 글에서는 그래픽스 강의에서 학습한 Ray Tracing과 관련된 지식들과 Ray Tracing 관련 과제를 진행했던 경험 그리고 이를 개선하기 위해 계획하고 있는 점을 다룰 것이다.</p><h2 id="ray-tracing">Ray Tracing<a href="#ray-tracing" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="local-vs-global-illumination-models">Local vs Global Illumination Models<a href="#local-vs-global-illumination-models" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Local/Direct illumination models<ul><li>A surface point receives light directly from all light sources</ul><li>Global illumination models<ul><li>A surface point receives light after the light rays interact with other objects</ul></ul><p><b>Ray Tracing</b>은 Illumination models를 나누는 두 개의 큰 틀 중에서 Global illumination models 중 하나이다. Ray Tracing은 또 다시 두 개로 나뉜다. 바로 Forward Ray Tracing과 Backward Ray Tracing이다.</p><p><img data-src="/assets/img/raytracing/1/RayTracing.png" alt="ray-tracing" data-proofer-ignore></p><h3 id="forward-ray-tracing">Forward Ray Tracing<a href="#forward-ray-tracing" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Forward Ray Tracing은 실제 빛의 작용과 굉장히 유사하다. 광원(Light Sources)에서 여러 Ray를 발사하여 여러 물체에 상호작용한 뒤, 카메라나 인간의 눈으로 들어오는 방식으로 구현하는 것을 말한다. 이는 상술했듯이 실제 빛의 작용과 굉장히 유사하여 직관적인 장점을 가지고 있다. 하지만 광원에서 출발한 Ray가 최종적으로 카메라에 들어가는지 알 수 없기 때문에 무수하게 많은 Ray를 계산해야 해서 컴퓨터로 구현하기에는 무리가 있다.</p><h3 id="backward-ray-tracing">Backward Ray Tracing<a href="#backward-ray-tracing" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>이 문제를 해결한 것이 바로 Backward Ray Tracing이다. Forward Ray Tracing과는 다르게 광원에서 Ray가 출발하는 것이 아닌 카메라 혹은 눈에서 Ray가 출발한다. <code class="language-plaintext highlighter-rouge">300 x 200</code> 이미지를 구성한다고 가정하자. 그렇다면 컴퓨터는 <code class="language-plaintext highlighter-rouge">300 x 200 = 60000</code>개의 정량적인 Ray만 계산하면 된다. 따라서 보통 Ray Tracing을 구현한다고 하면 Backward Ray Tracing으로 구현하는 경우가 많다.</p><h2 id="구현">구현<a href="#구현" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Ray Tracing을 구현하기 위해서는 크게 4가지를 구현하면 된다.</p><ol><li>Local illumination (e.g. Phong illumination model)<li>Shadow<li>Reflection<li>Refraction</ol><p>이 중에서 Local illumination은 다음 기회에 다루도록 하고 나머지 2, 3 그리고 4번을 다뤄보도록 하겠다. 넘어가기 전에 간단하게 Local illumination을 설명하자면 위에서 언급했듯이 <code class="language-plaintext highlighter-rouge">A surface point receives light directly from all light sources</code>. 즉, 빛에 의해서 표면이 얼마나 밝게 표현되는지를 나타내는 개념이다. 따라서 빛을 바라보고 있는 표면은 밝아지고 빛을 등지고 있는 표면은 어두워진다. 더 자세한 내용은 나중에 다뤄보겠다.</p><p><i>(이 때 빛을 바라보고 있는 표면이란 Surface의 Normal Vector를 <code class="language-plaintext highlighter-rouge">N</code>, 우리가 주목하고 있는 표면 위의 점에서 광원을 이은 Vector를 <code class="language-plaintext highlighter-rouge">L</code>이라고 했을 때, <code class="language-plaintext highlighter-rouge">N·L &gt; 0</code>인 표면을 말한다.)</i></p><h3 id="자세한-구현-이전에">자세한 구현 이전에…<a href="#자세한-구현-이전에" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="과제-명세">과제 명세<a href="#과제-명세" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>과제로 제출한 코드를 활용하여 설명하기 때문에 전후에 부족한 설명이 있을 수 있다. 자세한 코드는 추후에 Github에 업로드하여 링크할 예정이다.</p><h4 id="precision-problem">Precision Problem<a href="#precision-problem" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>구현 코드를 보다보면 <code class="language-plaintext highlighter-rouge">hit_point</code>에서 $\epsilon$만큼 <code class="language-plaintext highlighter-rouge">hit_normal</code> 방향으로 이동하여 ray를 만드는 경우를 볼 수 있을 것이다. 이는 컴퓨터에서 실수를 구현하는 방식인 floating point 때문에 발생하는 precision problem을 해결하기 위한 작업인데, <code class="language-plaintext highlighter-rouge">hit_point</code>에서 정확하게 ray를 시작할 경우 intersection checking 과정에서 ray를 시작하는 그 물체에 닿아버릴 수 있기 때문이다.</p><p><img data-src="/assets/img/raytracing/1/Precision_1.png" alt="Precision1" data-proofer-ignore> <img data-src="/assets/img/raytracing/1/Precision_2.png" alt="Precision2" data-proofer-ignore></p><h3 id="shadow">Shadow<a href="#shadow" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Local illumination 설명을 본다면 Shadow가 구현이 되어있는게 아닌가라는 의문이 들 수 있다. 어느 정도는 맞는 이야기인 것이, 빛을 바라보고 있지 않은 표면은 Local illumination에 의해 어두워지기 떄문에 그림자가 구현되었다고 볼 수 있다. 하지만 여기서 다루는 내용은 Local illumination에서 다루지 않는, 빛을 바라보고 있는 표면이지만 광원과 표면 사이에 물체가 존재하여 빛이 가로막히는 경우를 말한다.</p><p><img data-src="/assets/img/raytracing/1/Shadow.png" alt="Shadow" data-proofer-ignore></p><p>이는 다음과 같이 구현할 수 있다.</p><ol><li>Surface Point로부터 Light까지의 Vector를 구한다.<li>모든 Entities에 대해 intersection 여부를 확인한다.<li>intersection이 없다면 Local illumination을 적용한다.<li>intersection이 있다면 검은색<code class="language-plaintext highlighter-rouge">RGB(0, 0, 0)</code>을 적용한다.</ol><p>자세한 구현은 다음과 같다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1"># For all lights
</span><span class="k">for</span> <span class="n">light</span> <span class="ow">in</span> <span class="n">light_list</span><span class="p">:</span>
    <span class="c1"># L vector
</span>    <span class="n">ray_to_light</span> <span class="o">=</span> <span class="n">Ray</span><span class="p">(</span><span class="n">hit_point</span> <span class="o">+</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">hit_normal</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">hit_point</span><span class="p">))</span>
    <span class="n">light_dist</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">hit_point</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">hit_point</span><span class="p">))</span>

    <span class="n">hit2_dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>
    <span class="n">hit2_obj</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">hit2_point</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">hit2_normal</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># Check intersection
</span>    <span class="n">hit2_dist</span><span class="p">,</span> <span class="n">hit2_obj</span><span class="p">,</span> <span class="n">hit2_point</span><span class="p">,</span> <span class="n">hit2_normal</span> <span class="o">=</span> <span class="n">check_intersection</span><span class="p">(</span><span class="n">ray_to_light</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hit2_obj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">hit2_dist</span> <span class="o">&gt;</span> <span class="n">light_dist</span><span class="p">:</span>
        <span class="c1"># There is no intersection between the surface point and the light
</span>        <span class="n">color</span> <span class="o">+=</span> <span class="n">local_shade</span><span class="p">(</span><span class="n">hit_obj</span><span class="p">.</span><span class="n">color</span><span class="p">,</span> <span class="n">ray</span><span class="p">,</span> <span class="n">ray_to_light</span><span class="p">,</span> <span class="n">light</span><span class="p">,</span> <span class="n">hit_normal</span><span class="p">,</span> <span class="n">light_dist</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="reflection">Reflection<a href="#reflection" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>다음은 반사(Reflection)이다.</p><p>반사의 구현은 현실의 물리법칙을 따른다. 따라서 입사각(angle of incidence) $\theta_{in}$과 반사각(angle of reflection) $\theta_{out}$이 같다.</p><p><img data-src="/assets/img/raytracing/1/Reflection.png" alt="Reflection" data-proofer-ignore></p><p>Reflect된 Ray의 color을 얻는 자세한 구현은 다음과 같다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">reflect_dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="nb">dir</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">hit_normal</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hit_normal</span><span class="p">,</span> <span class="o">-</span><span class="n">ray</span><span class="p">.</span><span class="nb">dir</span><span class="p">))</span>
<span class="n">reflect_ray</span> <span class="o">=</span> <span class="n">Ray</span><span class="p">(</span><span class="n">hit_point</span> <span class="o">+</span> <span class="mf">0.0001</span> <span class="o">*</span> <span class="n">hit_normal</span><span class="p">,</span> <span class="n">reflect_dir</span><span class="p">)</span>
<span class="n">color_reflect</span> <span class="o">=</span> <span class="n">trace_ray</span><span class="p">(</span><span class="n">reflect_ray</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="refraction">Refraction<a href="#refraction" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>다음은 굴절(Refraction)이다.</p><p>굴절 또한 기존의 물리법칙과 동일하게 구현한다. 스넬의 법칙(Snell’s law)에 따라 굴절 전 매질의 굴절률을 $\eta_{i}$, 굴절 후 매질의 굴절률을 $\eta_{r}$라 했을 때, 입사각(angle of incidence) $\theta_{in}$과 굴절각(angle of refraction) $\theta_{r}$은 다음과 같은 관계를 가진다.</p><p>$\eta_{i} sin{\theta_{i}} = \eta_{r} sin{\theta_{r}}$</p><p><img data-src="/assets/img/raytracing/1/Refraction.png" alt="Refraction" data-proofer-ignore></p><p>굴절을 구현할 때는 여러 상황을 가정하고 구현해야 한다. Shadow나 Reflection은 구현 시에 항상 incident ray가 surface normal 방향에서 들어왔지만 refraction은 surface를 뚫고 나아가는 ray가 만들어지기 때문에 ray가 surface normal의 반대 방향에서 들어오는 경우도 고려해주어야 한다. 또한 스넬의 법칙으로 계산된 $\theta_{r}$이 90도를 넘을 경우 <a href="https://ko.wikipedia.org/wiki/%EC%A0%84%EB%B0%98%EC%82%AC">전반사</a>가 일어난다. 따라서 이 경우에는 굴절이 아닌 반사를 적용시켜 주어야 한다.</p><p>또한 구현 시에 굴절하는 방향인 <code class="language-plaintext highlighter-rouge">T</code>는 3차원 상에서 계산되어야 하기 때문에 계산이 복잡하다. 그림을 참고하여 <code class="language-plaintext highlighter-rouge">T</code>를 <code class="language-plaintext highlighter-rouge">L</code>, <code class="language-plaintext highlighter-rouge">N</code> 그리고 $\cos\theta_i$로 나타내는 유도과정은 다음과 같다.</p><p><img data-src="/assets/img/raytracing/1/Refraction_2.png" alt="Refraction2" data-proofer-ignore></p><p>$Let$ $\eta = { {\eta_i} \over {\eta_r} } = $ ${\sin\theta_r} \over {\sin\theta_i}$ , $M={(N{\cos{\theta_i}}-L)\over{\sin{\theta_i}}}$</p><p>$Then $</p><p>$T=-N\cos\theta_i+M\sin\theta_r$</p><p>$=-N\cos\theta_i+(N{\cos{\theta_i}}-L)\sin\theta_r/{\sin{\theta_i}}$</p><p>$=-N\cos\theta_i+(N{\cos{\theta_i}}-L)\eta$</p><p>$=[\eta\cos\theta_i-\cos\theta_r]N - \eta L$</p><p>$=[\eta\cos\theta_i-\sqrt{1-{\sin^2\theta_r}}]N - \eta L$</p><p>$=[\eta\cos\theta_i-\sqrt{1-\eta^2{\sin^2\theta_i}}]N - \eta L$</p><p>$=[\eta\cos\theta_i-\sqrt{1-\eta^2(1-{\cos^2\theta_i})}]N - \eta L$</p><p>이를 바탕으로 한 기본적인 refraction의 구현은 다음과 같다. 이 구현에서는 공기의 굴절률을 1로 가정하고, 반드시 매질 -&gt; 공기 혹은 공기 -&gt; 매질의 상황만 발생한다고 가정하였다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1"># hit_obj.ior = eta_r
# therefore, eta = 1 / hit_obj.ior
</span>
<span class="n">incident_angle</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hit_normal</span><span class="p">,</span> <span class="o">-</span><span class="n">ray</span><span class="p">.</span><span class="nb">dir</span><span class="p">)</span> <span class="c1"># cos(eta_i)
</span><span class="n">refract_dir</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">hit_obj</span><span class="p">.</span><span class="n">ior</span> <span class="o">*</span> <span class="n">incident_angle</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">hit_obj</span><span class="p">.</span><span class="n">ior</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">incident_angle</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">*</span> <span class="n">hit_normal</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">hit_obj</span><span class="p">.</span><span class="n">ior</span><span class="p">)</span> <span class="o">*</span> <span class="n">ray</span><span class="p">.</span><span class="nb">dir</span>
<span class="n">refract_dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">refract_dir</span><span class="p">)</span>
<span class="n">refract_ray</span> <span class="o">=</span> <span class="n">Ray</span><span class="p">(</span><span class="n">hit_point</span> <span class="o">-</span> <span class="mf">0.0001</span> <span class="o">*</span> <span class="n">hit_normal</span><span class="p">,</span> <span class="n">refract_dir</span><span class="p">,</span> <span class="n">hit_obj</span><span class="p">.</span><span class="n">ior</span><span class="p">)</span>

<span class="n">color_refract</span> <span class="o">=</span> <span class="n">trace_ray</span><span class="p">(</span><span class="n">refract_ray</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></table></code></div></div><p>이 외에도 위에서 서술한 전반사나 매질의 내부에서 공기로 나올 때를 따로 구현해준다.</p><p>전반사 확인</p><div class="language-python highlighter-rouge"><div class="code-header"> <span label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">incident_angle</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hit_normal</span><span class="p">,</span> <span class="o">-</span><span class="n">ray</span><span class="p">.</span><span class="nb">dir</span><span class="p">)</span>
<span class="n">incident_sin</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">incident_angle</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># check total internal reflection
</span><span class="k">if</span> <span class="n">incident_sin</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">hit_obj</span><span class="p">.</span><span class="n">ior</span><span class="p">:</span>
    <span class="p">...</span>
</pre></table></code></div></div><p>매질의 내부에서 공기로 나올 경우</p><div class="language-python highlighter-rouge"><div class="code-header"> <span label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hit_normal</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="nb">dir</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span> 
    <span class="p">...</span>
</pre></table></code></div></div><h2 id="추가-구현">추가 구현<a href="#추가-구현" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="intersection-checking">Intersection Checking<a href="#intersection-checking" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>표면에서 그림자, 반사 그리고 굴절을 구현하였으면 실제로 ray가 물체와 부딫히는지 확인하는 코드를 작성할 필요가 있다. 본 구현에서는 <code class="language-plaintext highlighter-rouge">Sphere</code>와 <code class="language-plaintext highlighter-rouge">Polygon</code>의 경우에 대해 설명하겠다.</p><p>이 때 필요로 하는 값은 ray의 시작 지점에서 부딫힌 point가 ray로부터 얼마나 떨어져 있는지를 나타내는 <code class="language-plaintext highlighter-rouge">t</code>값을 구한다. 이 <code class="language-plaintext highlighter-rouge">t</code>값을 활용하여 가장 앞에 있는 물체가 무엇인지를 확인한다.</p><h4 id="sphere">Sphere<a href="#sphere" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/raytracing/1/Sphere_Inter.png" alt="SphereInter" data-proofer-ignore></p><p>$P = O+Rt$</p><p>$|P-C|^2 = r^2$</p><p>$|P|^2-2P \cdot C+|C|^2=r^2$</p><p>$|O|^2+2(O \cdot R)t+|R|^2t^2-2(O+Rt) \cdot C+|C|^2 = r^2$</p><p>$|R|^2t^2+2R \cdot (O-C)t+|O-C|^2-r^2=0$</p><p>$Let$ $a=|R|^2, b=2R \cdot (O-C), c=|O-C|^2-r^2$</p><p>$Then, $ $at^2+bt+c=0$</p><p>따라서 <code class="language-plaintext highlighter-rouge">t1</code>과 <code class="language-plaintext highlighter-rouge">t2</code>를 구하려면 이차방정식을 풀면 된다. 이 중 <code class="language-plaintext highlighter-rouge">O</code>에 가까운 값을 사용한다. 이를 코드로 나타내면 다음과 같다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1"># class Sphere
</span><span class="k">def</span> <span class="nf">interact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ray</span><span class="p">:</span> <span class="n">Ray</span><span class="p">):</span>
    <span class="n">oc</span> <span class="o">=</span> <span class="n">ray</span><span class="p">.</span><span class="n">orig</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">center</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="nb">dir</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="nb">dir</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">oc</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="nb">dir</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">oc</span><span class="p">,</span> <span class="n">oc</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">discriminant</span> <span class="o">=</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
    <span class="k">if</span> <span class="n">discriminant</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">discriminant</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">discriminant</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t1</span> <span class="k">if</span> <span class="n">t1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">t2</span> <span class="k">if</span> <span class="n">t2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">None</span>
</pre></table></code></div></div><h4 id="polygon">Polygon<a href="#polygon" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>Polygon의 intersection 구현은 두 부분으로 나눌 수 있다.</p><ol><li>Polygon을 포함하는 평면을 ray가 지나는 점 구하기 ($t&gt;0$인 <code class="language-plaintext highlighter-rouge">t</code>를 구하기)<li>그 점이 Polygon을 구성하는 삼각형 안에 있는지 여부 확인</ol><p><img data-src="/assets/img/raytracing/1/Poly_Inter_1.png" alt="PolyInter1" data-proofer-ignore></p><p>$P = O+Rt$</p><p>$N \cdot (P-v_0)= 0$</p><p>$N\cdot P = N \cdot v_0$</p><p>$N \cdot (O +Rt) = N \cdot v_0$</p><p>$N \cdot Rt = N \cdot (v_0 - O)$</p><p>$t = {N \cdot (v_0 - O) \over N \cdot R}$</p><p>이 과정을 통해 Polygon이 속한 평면 위의 점 <code class="language-plaintext highlighter-rouge">P</code>를 구할 수 있다. 이제 <code class="language-plaintext highlighter-rouge">P</code>가 실제로 Polygon 위에 있는지를 확인하면 된다. 이는 <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">Barycentric coordinate system</a>을 통해 확인할 수 있다.</p><p>간단히 말해서 점 <code class="language-plaintext highlighter-rouge">P</code>가 세 점 $v_0$, $v_1$ 그리고 $v_2$가 이루는 평면 위에 있고 $P = uv_0 + vv_1 + wv_2$로 나타낼 때, $u, v, w &gt;= 0$를 만족하면 점 <code class="language-plaintext highlighter-rouge">P</code>는 세 점이 이루는 평면 위에 있다는 결론을 내릴 수 있다.</p><p>이 전체를 코드로 나타내면 다음과 같다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1"># class Polygon
</span><span class="k">def</span> <span class="nf">interact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ray</span><span class="p">:</span> <span class="n">Ray</span><span class="p">):</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span>

    <span class="n">dot_prod</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="nb">dir</span><span class="p">)</span>

    <span class="c1"># The ray does not interact with the polygon
</span>    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">dot_prod</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    
    <span class="n">ov</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">orig</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span> <span class="o">/</span> <span class="n">dot_prod</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">int_point</span> <span class="o">=</span> <span class="n">ray</span><span class="p">.</span><span class="n">orig</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">ray</span><span class="p">.</span><span class="nb">dir</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">barycentric</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">int_point</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">t</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># The ray does not interact with the polygon
</span>        <span class="k">return</span> <span class="bp">None</span>
</pre></table></code></div></div><h2 id="결과">결과<a href="#결과" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="결과물">결과물<a href="#결과물" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/raytracing/1/Result.png" alt="Result" data-proofer-ignore></p><p>위 조건을 바탕으로 코드를 작성한 결과 성공적으로 결과물을 얻어낼 수 있었다. 가장 가까운 구는 굴절률을 2로 설정한 구이고 그 뒤에 있는 구는 완전 반사가 일어나는 구이다. 그리고 왼쪽 구석에 반사판을 두어 반사 효과가 더 극적으로 보일 수 있도록 설정하였다.</p><h3 id="아쉬운-점">아쉬운 점<a href="#아쉬운-점" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>과제 조건이 Python으로 구현하는 것이었기 때문에 속도가 너무 느린 것이 단점이었다. 위와같은 장면을 얻기 위해서는 약 10분 이상 기다려야 했으며 cpu multiprocessing을 활용하여 약 5~10배정도 속도를 가속했음에도 불구하고 이와 같은 시간이 걸렸다. GPU를 활용하여 결과를 냈다면 훨씬 빠른 속도로 결과를 얻어낼 수 있었을텐데 과제 기간이 시험기간과 겹치기도 했고 GPU 활용을 단순 모델 학습이 아니라 원하는 계산을 하도록 작업해본 적이 없어서 시간 내에 구현해보지 못했다.</p><p>또한 부드러운 그림자를 얻기 위해서는 Point Light이 아니라 Area Light이 필요했는데 과제 명세에서 Point Light을 여러 개 배치하여 Area Light의 효과를 얻어도 인정한다는 내용이 있었다. 그래서 25개의 Point Light을 사용해서 구현하였는데 생각보다 만족스러운 결과를 얻지 못했다.</p><p>그리고 수업시간에 다룬 Depth of Field나 Caustics를 구현하지 못한 아쉬움도 있었다. Depth of Field는 우리가 흔히 아는 아웃포커싱이고 Caustics는 위의 결과에서는 굴절 및 반사에 따라 생겨나는 밝은 부분을 뜻한다. 위의 결과물을 예시로 든다면 가장 앞쪽의 구의 그림자 속에 실제로는 빛이 굴절되어 모인 밝은 부분이 생겨나야 하지만 이러한 것이 구현되지 못했다.</p><h3 id="목표">목표<a href="#목표" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>일단 Python으로 짜여있는 코드를 C/C++로 옮겨 더 높은 performance를 보이는 환경에서 Ray Tracing을 구현해보고자 한다. 또한 이번에는 GPU까지 활용하여 만족스러운 결과를 더 빠른 속도로 얻을 수 있도록 목표해보고자 한다. 또한 위에서 언급했던 DoF, Caustics를 포함하여 수업 시간에 다룬 더 다양한 Visual Effects를 구현할 것이다.</p><h2 id="참고-자료">참고 자료<a href="#참고-자료" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>Jungdam Won, Ray Tracing 수업 자료<li>Wikipedia, Refraction, https://en.wikipedia.org/wiki/Refraction<li>Wikipedia, Reflection, https://en.wikipedia.org/wiki/Reflection_(physics)<li>Wikipedia, Barycentric coordinate system, https://en.wikipedia.org/wiki/Barycentric_coordinate_system</ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/graphics/'>graphics</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/study/" class="post-tag no-text-decoration" >study</a> <a href="/tags/graphics/" class="post-tag no-text-decoration" >graphics</a> <a href="/tags/ray-tracing/" class="post-tag no-text-decoration" >ray-tracing</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 게시물은 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Ray Tracing (1) - 강의 리뷰 - Veldic's Blog&url=https://veldic.github.io/posts/ray-tracing-1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Ray Tracing (1) - 강의 리뷰 - Veldic's Blog&u=https://veldic.github.io/posts/ray-tracing-1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Ray Tracing (1) - 강의 리뷰 - Veldic's Blog&url=https://veldic.github.io/posts/ray-tracing-1/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ray-tracing-1/">Ray Tracing (1) - 강의 리뷰</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/clone-coding/">clone-coding</a> <a class="post-tag" href="/tags/graphics/">graphics</a> <a class="post-tag" href="/tags/project/">project</a> <a class="post-tag" href="/tags/ray-tracing/">ray-tracing</a> <a class="post-tag" href="/tags/study/">study</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/written-dev/"><div class="card-body"> <em class="timeago small" date="2021-01-18 00:00:00 +0900" >2021년 01월 18일</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>씀 - 클론코딩</h3><div class="text-muted small"><p> 씀 클론코딩 와플 스튜디오에서 2020년 하반기 Rookies Seminar가 끝나고 진행한 toy-project로 여러 조로 나누어서 실제 서비스를 클론 코딩하는 프로젝트를 진행하였고 우리 조는 글쓰기 어플인 ‘씀’을 클론 코딩하였다. 코드는 아래 repo에서 확인해볼 수 있다. github repo 구현 범위 기간이 정해져 있었던 프...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/written-dev/" class="btn btn-outline-primary" prompt="이전 글"><p>씀 - 클론코딩</p></a> <span class="btn btn-outline-primary disabled" prompt="다음 글"><p>-</p></span></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/veldic">Seungmin Lee</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/clone-coding/">clone-coding</a> <a class="post-tag" href="/tags/graphics/">graphics</a> <a class="post-tag" href="/tags/project/">project</a> <a class="post-tag" href="/tags/ray-tracing/">ray-tracing</a> <a class="post-tag" href="/tags/study/">study</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
